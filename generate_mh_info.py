import os
import open3d as o3d
import pygame
from transforms3d.axangles import axangle2mat
import copy
import config
from hand_mesh import HandMesh
from kinematics import mpii_to_mano
from wrappers import ModelPipeline
from utils import *
import tensorflow as tf


def live_application_img(image, i, joints_xyz):
  """
  Launch an application that reads from a webcam and estimates hand pose at
  real-time.

  The captured hand must be the right hand, but will be flipped internally
  and rendered.

  Parameters
  ----------
  capture : object
    An object from `capture.py` to read capture stream from.
  """
  os.system("mkdir ./mh_one_hand_rotation/")
  generated_imgs = "./mh_one_hand_rotation/"
  print(i)
  o3d.visualization.RenderOption.line_width = 0.0
  view_mat = axangle2mat([1, 0, 0], np.pi) # align different coordinate systems
  window_size = 1080

  hand_mesh = HandMesh(config.HAND_MESH_MODEL_PATH)
  # print(hand_mesh.faces)
  mesh = o3d.geometry.TriangleMesh()
  mesh.triangles = o3d.utility.Vector3iVector(hand_mesh.faces)
  mesh.vertices = \
    o3d.utility.Vector3dVector(np.matmul(view_mat, hand_mesh.verts.T).T * 1000)
  mesh.compute_vertex_normals()

  viewer = o3d.visualization.Visualizer()
  viewer.create_window(
    width=window_size + 1, height=window_size + 1,
    window_name='Minimal Hand - output'
  )

  viewer.add_geometry(mesh, reset_bounding_box=False)
  view_control = viewer.get_view_control()
  cam_params = view_control.convert_to_pinhole_camera_parameters()
  extrinsic = cam_params.extrinsic.copy()
  extrinsic[0:3, 3] = 0
  cam_params.extrinsic = extrinsic
  cam_params.intrinsic.set_intrinsics(
    window_size + 1, window_size + 1, config.CAM_FX, config.CAM_FY,
    window_size // 2, window_size // 2
  )
  view_control.convert_from_pinhole_camera_parameters(cam_params)
  view_control.set_constant_z_far(1000)
  render_option = viewer.get_render_option()
  render_option.load_from_json('./render_option.json')
  viewer.update_renderer()

  ############ input visualization ############
  pygame.init()
  display = pygame.display.set_mode((window_size, window_size))
  pygame.display.set_caption('Minimal Hand - input')

  ############ misc ############
  mesh_smoother = OneEuroFilter(4.0, 0.0)
  clock = pygame.time.Clock()
  model = ModelPipeline()
  frame_large = image
  # frame_large = np.flip(frame_large, axis=1).copy()
  frame = imresize(frame_large, (128, 128))

  joint_locations, theta_mpii = model.process(frame, joints_xyz)  # yy: joint locations & joint rotations
  theta_mano = mpii_to_mano(theta_mpii)  # yy: shape: (21, 4)
  # print(theta_mpii.shape)

  # print(np.asarray(joint_locations).shape)
  
  v, joint_xyz = hand_mesh.set_abs_quat(theta_mano)
  v *= 2 # for better visualization
  v = v * 1000 + np.array([0, 0, 400])
  # print(v.shape)
  v = mesh_smoother.process(v)
  mesh.triangles = o3d.utility.Vector3iVector(hand_mesh.faces)  # (1538, 3)
  mesh.vertices = o3d.utility.Vector3dVector(np.matmul(view_mat, v.T).T)  # (778, 3)
  mesh.paint_uniform_color(config.HAND_COLOR)
  mesh.compute_triangle_normals()
  mesh.compute_vertex_normals()

  # yy: draw cubes and add cubes to the viewer
  mesh_box = o3d.geometry.TriangleMesh.create_box(width=2, height=2, depth=0.001)
  mesh_box.compute_vertex_normals()
  mesh_box.paint_uniform_color([0., 0., 0.])
  # print(np.asarray(mesh_box.vertices))

  v = copy.deepcopy(joint_xyz)
  v *= 2  # for better visualization
  v = v * 1000 + np.array([0, 0, 400])  # old: [0, 0, 360]
  v = np.matmul(view_mat, v.T).T
  np.save(f'{generated_imgs}/{i}_joint_locations.npy', np.asarray(v))
  if(i == 10):
    print(v)

  for q in range(21):
    new_mesh = copy.deepcopy(mesh_box)
    # new_mesh.set_antialiasing(False)
    viewer.add_geometry(new_mesh, reset_bounding_box=False)
    # r, g, b = 1. * 0.04 * q, 1. * 0.04 * (20-q), 1. * 0.05 * q
    # new_mesh.paint_uniform_color(np.array([r, g, b]))  # 0.04
    new_mesh.paint_uniform_color(np.array([1., 1., 1.]) * 0.04 * q)
    new_mesh.translate(tuple(v[q, :]), relative=True)
    # print(np.asarray(new_mesh.vertices))
    
    # new_mesh.paint_uniform_color(color_ls[q])  # 0.04
    viewer.update_geometry(new_mesh)
    viewer.poll_events()

  # print(np.asarray(new_mesh.vertices).shape)
  # yy: add color by direction ("side_idx.npy" and "side_ratio.npy" have been generated by me, so I comment this part of code)
  # def calc_angle(vec):
  #   return np.arcsin(np.abs(vec[2]) / np.linalg.norm(vec))
  #
  # # save side info
  # ver_normals = np.asarray(mesh.vertex_normals)
  # angles = np.apply_along_axis(calc_angle, 1, ver_normals)
  # side_decide_ls = np.apply_along_axis(calc_angle, 1, ver_normals) < (np.pi / 6)
  # side_angles = angles[side_decide_ls]
  # side_idx = side_decide_ls.nonzero()[0]
  # side_ratio = np.array([((np.pi / 6) - angle) / (np.pi / 3) if ver_normals[side_idx[s_idx], 2] > 0 else ((np.pi / 6) + angle) / (np.pi / 3) for s_idx, angle in enumerate(side_angles)])
  # np.save("side_idx.npy", side_idx)
  # np.save("side_ratio.npy", side_ratio)


  # yy: Paint colors based on the index (light for ventral, dark for dorsal, and gradually decresing color in the side part of hand)
  up_idx = np.load("up_idx.npy")
  side_idx = np.load("side_idx.npy")
  side_ratio = np.load("side_ratio.npy")
  lgth = np.asarray(mesh.vertex_colors).shape[0]
  # print(np.asarray(mesh.vertex_colors).shape)
  # print(up_idx.shape)
  for j in range(lgth):
    if j in up_idx:
      # mesh.vertex_colors[j] = np.array([0.6, 0.5, 0.4])
      mesh.vertex_colors[j] = np.array([0.1, 0.1, 0.1])
    else:
      # mesh.vertex_colors[j] = np.array([0.1, 0.2, 0.3])
      mesh.vertex_colors[j] = np.array([0.9, 0.9, 0.9])
    if j in side_idx:
      color = 0.9 - side_ratio[list(side_idx).index(j)] * (0.9 - 0.1)
      mesh.vertex_colors[j] = np.array([color, color, color])


  # yy: remove mesh (minimal hand), only show cubes.
  viewer.remove_geometry(mesh)
  viewer.poll_events()
  viewer.capture_screen_image(os.path.join(generated_imgs, str(i) + '_1.png'))

  wire_mesh = o3d.geometry.LineSet.create_from_triangle_mesh(mesh)

  # yy: add mesh back, show the minimal hand.
  viewer.add_geometry(mesh, reset_bounding_box=False)
  viewer.poll_events()
  viewer.capture_screen_image(os.path.join(generated_imgs, str(i) + '_2.png'))

  # yy: useless now, could comment.
  viewer.remove_geometry(mesh)
  viewer.add_geometry(wire_mesh, reset_bounding_box=False)
  viewer.poll_events()
  viewer.capture_screen_image(os.path.join(generated_imgs, str(i) + '_3.png'))


  display.blit(
    pygame.surfarray.make_surface(
      np.transpose(
        imresize(frame_large, (window_size, window_size)
      ), (1, 0, 2))
    ),
    (0, 0)
  )


  pygame.display.update()

  # print(generated_imgs)
  os.system(f'mkdir {generated_imgs}')
  pygame.image.save(display, os.path.join(generated_imgs, str(i) + '_0.png'))
  print(generated_imgs, str(i) + '_0.png')

  mat = o3d.visualization.rendering.MaterialRecord()
  mat.shader = "unlitLine"
  mat.line_width = 1.0  # note that this is scaled with respect to pixels,


if __name__ == '__main__':
  img_folder_pth = './datasets/rotation/'  # yy: dataset path containing the rgb images
  num_img_to_generate = 10 # yy: number of minimal hands you hope to generate

  dict_mediapipe_mano = {0: 0, 1 : 5, 2:6, 3:7, 4:8, 5:9, 6:10, 7:11, 8:12, 9:13, 10:14, 11:15,
                         12:16, 13:17, 14: 18, 15:19, 16:20, 17:1, 18:2, 19:3, 20:4, }
  for i, img in enumerate(sorted(os.listdir(img_folder_pth))[:num_img_to_generate]):
    # print(img)
    # if(i!=10):
    #   continue
    img_path = os.path.join(img_folder_pth, img)
    img = cv2.imread(img_path)
    joints_xyz1 = np.zeros((21, 3))
    joints_xyz = np.zeros((21, 3))
    # try:
    #   joints_xyz = np.load('./One_Hand_mediapipe/fingertips' + str(i) + '.npy', allow_pickle=True)
    #   for p in range(21):
    #     joints_xyz1[p] = joints_xyz[dict_mediapipe_mano[p]]
    #   print(joints_xyz)
    #   joints_xyz = joints_xyz1
    #   print(joints_xyz)
    # except:
    #   continue
    # print(joints_xyz.shape)
    # np.transpose(joints_xyz, (1, 2, 0))
    # print(np.max(joints_xyz[:, 0]))
    # joints_xyz[:, 0] = 1 - joints_xyz[:, 0]
    # joints_xyz[:, 1] = 1 - joints_xyz[:, 1]

    # joints_xyz = np.array([np.array([point[0], point[1], point[2]]) for point in joints_xyz])
    # joints_xyz = joints_xyz*(1080)
    live_application_img(img, i, joints_xyz)
    tf.reset_default_graph()
